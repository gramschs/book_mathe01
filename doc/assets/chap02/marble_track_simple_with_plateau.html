<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interaktive Kugelbahn-Simulation</title>
    <style>
    body {
        margin: 0;
        padding: 10px;
        font-family: Arial, sans-serif;
        background: #f8f9fa;
    }
    
    .kugelbahn-container {
        width: 100%;
        max-width: 800px;
        margin: 0 auto;
        text-align: center;
        padding: 5px;
    }
    
    .kugelbahn-canvas {
        background: #f8f9fa;
        margin: 5px auto;
        display: block;
        box-shadow: none;
        cursor: grab;
        width: 100%;           /* NEU: Responsive Breite */
        height: auto;          /* NEU: Proportionale Höhe */
        max-width: 800px;      /* NEU: Maximale Breite */
    }
    
    .kugelbahn-canvas:active {
        cursor: grabbing;
    }
    
    .kugelbahn-controls {
        margin: 8px 0;
    }
    
    .kugelbahn-button {
        background: #005A94;
        color: white;
        border: none;
        padding: 12px 24px;
        margin: 0 10px;
        cursor: pointer;
        border-radius: 6px;
        font-size: 16px;
        font-weight: bold;
        transition: background-color 0.3s;
    }
    
    .kugelbahn-button:hover {
        background: #004080;
    }
    
    .kugelbahn-button:disabled {
        background: #cccccc;
        cursor: not-allowed;
    }
    
    .instructions {
        margin: 5px 0;
        color: #666;
        font-style: italic;
        font-size: 12px;        /* NEU: Angepasste Schriftgröße */
    }
    
     @media (max-width: 600px) {
        body {
            padding: 5px;
        }
        
        .kugelbahn-canvas {
            margin: 5px auto;
            border-width: 1px;
        }
        
        .kugelbahn-button {
            padding: 8px 16px;
            font-size: 14px;
            margin: 0 5px;
        }
        
        .instructions {
            font-size: 11px;
            margin: 3px 0;
        }
        
        .kugelbahn-controls {
            margin: 5px 0;
        }
    }

    @media (max-width: 400px) {
        .kugelbahn-button {
            padding: 6px 12px;
            font-size: 12px;
        }
        
        .instructions {
            font-size: 10px;
        }
    }
</style>
</head>
<body>
    <div class="kugelbahn-container">
        <canvas class="kugelbahn-canvas"></canvas>
        
        <div class="kugelbahn-controls">
            <button class="kugelbahn-button kugelbahn-start">Starte Animation</button>
        </div>
        
    </div>

    <script>
        class InteractiveKugelbahn {
        constructor(canvasSelector, functionDef, options = {}) {
            this.canvas = document.querySelector(canvasSelector);
            this.ctx = this.canvas.getContext('2d');
            
            // NEU: Responsive Canvas-Größe
            this.setupResponsiveCanvas();
            
            this.functionDef = functionDef;
            
            this.options = {
                animationSpeed: 0.005,
                ballSize: 14,
                autoStart: true,
                showColorBar: true,
                colormap: 'coolwarm',
                ...options
            };
            
            // Animation State
            this.ballPosition = 0;
            this.isAnimating = false;
            this.hasAutoStarted = false;
            
            // Drag & Drop State
            this.isDragging = false;
            this.lastPointerX = 0;
            this.dragStartX = 0;
            
            // NEU: Layout nach Canvas-Setup
            this.updateLayout();
            this.initializeColorPalette();
            this.computeDerivativeRange();
            this.setupEventListeners();
            this.setupDragAndDrop();
            this.setupAutoStart();
            this.setupResizeHandler(); // NEU
            this.render();
            }
            
       setupResponsiveCanvas() {
            const container = this.canvas.closest('.kugelbahn-container');
            let containerWidth = 800;
            
            if (container) {
                containerWidth = container.offsetWidth || 
                                container.clientWidth || 
                                800;
            }
            
            const maxWidth = Math.min(containerWidth - 40, 800);
            this.width = Math.max(320, maxWidth);
            
            // KONSERVATIVE Höhen-Berechnung
            if (this.width <= 480) {
                // Mobile: Nicht zu flach
                this.height = Math.round(this.width * 0.6);  // 480x288
            } else {
                // Desktop/Tablet: Wie vorher
                this.height = Math.round(this.width * 0.5);  // 730x365
            }
            
            // Sinnvolle Grenzen
            this.height = Math.max(200, Math.min(400, this.height));
            
            this.canvas.width = this.width;
            this.canvas.height = this.height;
            
            console.log(`Canvas-Größe: ${this.width}x${this.height} (Container: ${containerWidth})`);
        }

            updateLayout() {
                // Intelligente Margin-Berechnung basierend auf Canvas-Größe
                if (this.width <= 500) {
                    // Kleine Canvas: Größere Margins für Labels
                    this.margin = Math.max(60, this.width * 0.12);
                } else {
                    // Normale Canvas: Standard-Margins
                    this.margin = Math.max(50, Math.min(70, this.width * 0.08));
                }
                
                this.plotWidth = this.width - 2 * this.margin;
                this.plotHeight = this.height - 2 * this.margin;
                
                // NEU: Responsive Kugelgröße
                if (this.width <= 400) {
                    this.responsiveBallSize = Math.max(8, this.options.ballSize * 0.7);  // 70% kleiner
                } else if (this.width <= 500) {
                    this.responsiveBallSize = Math.max(10, this.options.ballSize * 0.85); // 15% kleiner
                } else {
                    this.responsiveBallSize = this.options.ballSize; // Original-Größe
                }
                
                console.log(`Layout: Margin=${this.margin}, Plot=${this.plotWidth}x${this.plotHeight}, BallSize=${this.responsiveBallSize}`);
            }

            setupResizeHandler() {
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        this.setupResponsiveCanvas();
                        this.updateLayout();
                        this.render();
                    }, 250);
                });
            }
            // === DRAG & DROP FUNCTIONALITY ===
            
            setupDragAndDrop() {
                // Mouse Events
                this.canvas.addEventListener('mousedown', (e) => this.handlePointerStart(e));
                this.canvas.addEventListener('mousemove', (e) => this.handlePointerMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handlePointerEnd(e));
                this.canvas.addEventListener('mouseleave', (e) => this.handlePointerEnd(e));
                
                // Touch Events für Mobile
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.handlePointerStart(touch);
                }, { passive: false });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.handlePointerMove(touch);
                }, { passive: false });
                
                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handlePointerEnd(e);
                }, { passive: false });
            }
            
            getPointerPosition(event) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };
            }
            
            isBallClicked(pointerX, pointerY) {
                const [xMin, xMax] = this.functionDef.domain;
                const currentX = xMin + (xMax - xMin) * this.ballPosition;
                const currentY = this.functionDef.func(currentX);
                const [ballX, ballY] = this.mathToCanvas(currentX, currentY);
                
                const distance = Math.sqrt((pointerX - ballX)**2 + (pointerY - ballY)**2);
                return distance <= this.responsiveBallSize + 15;
            }
            
            handlePointerStart(event) {
                const pointer = this.getPointerPosition(event);
                
                if (this.isBallClicked(pointer.x, pointer.y)) {
                    this.isDragging = true;
                    this.lastPointerX = pointer.x;
                    this.dragStartX = pointer.x;
                    this.canvas.style.cursor = 'grabbing';
                    
                    // Animation stoppen falls aktiv
                    if (this.isAnimating) {
                        this.stopAnimation();
                    }
                }
            }
            
            handlePointerMove(event) {
                const pointer = this.getPointerPosition(event);
                
                if (this.isDragging) {
                    // Berechne Bewegung in Pixel
                    const deltaX = pointer.x - this.lastPointerX;
                    
                    // Konvertiere zu Positions-Änderung (0 bis 1)
                    const positionDelta = deltaX / this.plotWidth;
                    this.ballPosition += positionDelta;
                    
                    // Begrenze auf gültigen Bereich
                    this.ballPosition = Math.max(0, Math.min(1, this.ballPosition));
                    
                    this.lastPointerX = pointer.x;
                    this.render();
                } else {
                    // Cursor-Feedback auch ohne Ziehen
                    if (this.isBallClicked(pointer.x, pointer.y)) {
                        this.canvas.style.cursor = 'grab';
                    } else {
                        this.canvas.style.cursor = 'default';
                    }
                }
            }
            
            handlePointerEnd(event) {
                if (this.isDragging) {
                    this.isDragging = false;
                    this.canvas.style.cursor = 'grab';
                }
            }
            
            // === REST DER IMPLEMENTIERUNG ===
            
            initializeColorPalette() {
                const colorPalettes = {
                    bluewhitered: [
                        '#e60000', '#eb3232', '#f06666', '#f59999', '#facccc', 
                        '#ffffff',
                        '#ccdee9', '#99bdd4', '#669cbe', '#327aa9', '#005a94'
                    ],

                    viridis: [
                        '#440154', '#482475', '#414487', '#355f8d', '#2a788e',
                        '#21908c', '#22a884', '#42be71', '#7ad151', '#bddf26',
                        '#fde725'
                    ],
                    coolwarm: [
                        '#3b4cc0', '#5977e3', '#7fa5f0', '#a7cdf2', '#d1e5f0',
                        '#f7f7f7', '#fddbc7', '#f4a582', '#d6604d', '#b2182b'
                    ],
                    plasma: [
                        '#0d0887', '#41049d', '#6a00a8', '#8f0da4', '#b12a90',
                        '#cc4778', '#e16462', '#f2844b', '#fca636', '#fcce25',
                        '#f0f921'
                    ],

                    yellowredwhite: [
                        '#E60000', '#FF3333', '#FF6666', '#FF9999', '#FFFFFF',  
                        '#FFCC66', '#FFB84D', '#FFA433', '#FFEC7F'  
                    ]
                };
                const selectedPalette = colorPalettes[this.options.colormap] || colorPalettes.viridis;
                this.colors = selectedPalette;
                console.log(`Palette ${this.options.colormap}: ${this.colors.length} Farben, Mitte: ${this.colors[Math.floor(this.colors.length/2)]}`);

            }
            
            generateColorGradient(basePalette, steps) {
                const colors = [];
                const segments = basePalette.length - 1;
                
                for (let i = 0; i < steps; i++) {
                    const position = i / (steps - 1);
                    const segmentIndex = Math.floor(position * segments);
                    const segmentPosition = (position * segments) - segmentIndex;
                    
                    const startColor = basePalette[Math.min(segmentIndex, segments)];
                    const endColor = basePalette[Math.min(segmentIndex + 1, segments)];
                    
                    colors.push(this.interpolateHexColors(startColor, endColor, segmentPosition));
                }
                
                return colors;
            }
            
            interpolateHexColors(color1, color2, t) {
                const r1 = parseInt(color1.slice(1, 3), 16);
                const g1 = parseInt(color1.slice(3, 5), 16);
                const b1 = parseInt(color1.slice(5, 7), 16);
                
                const r2 = parseInt(color2.slice(1, 3), 16);
                const g2 = parseInt(color2.slice(3, 5), 16);
                const b2 = parseInt(color2.slice(5, 7), 16);
                
                const r = Math.round(r1 + (r2 - r1) * t);
                const g = Math.round(g1 + (g2 - g1) * t);
                const b = Math.round(b1 + (b2 - b1) * t);
                
                return `rgb(${r}, ${g}, ${b})`;
            }
            
            computeDerivativeRange() {
                const [xMin, xMax] = this.functionDef.domain;
                let minDeriv = Infinity;
                let maxDeriv = -Infinity;
                
                for (let i = 0; i <= 1000; i++) {
                    const x = xMin + (xMax - xMin) * i / 1000;
                    const deriv = this.getDerivative(x);
                    
                    if (deriv < minDeriv) minDeriv = deriv;
                    if (deriv > maxDeriv) maxDeriv = deriv;
                }
                
                this.minDerivative = minDeriv;
                this.maxDerivative = maxDeriv;
                this.derivativeRange = maxDeriv - minDeriv;
            }
            
            getDerivative(x) {
                if (this.functionDef.derivative) {
                    return this.functionDef.derivative(x);
                }
                
                const h = 0.0001;
                const [xMin, xMax] = this.functionDef.domain;
                const x1 = Math.max(xMin, x - h);
                const x2 = Math.min(xMax, x + h);
                return (this.functionDef.func(x2) - this.functionDef.func(x1)) / (x2 - x1);
            }
            
            getColorFromDerivative(derivative) {
                if (Math.abs(derivative) < 1e-6) {
                    console.log(`DEBUG: derivative=${derivative}, whiteIndex=5`);
                    console.log(`DEBUG: colors[5] = ${this.colors[5]} (sollte #ffffff sein)`);
                    console.log(`DEBUG: Palette:`, this.colors);
                }
    

                if (this.derivativeRange === 0) {
                    return this.colors[Math.floor(this.colors.length / 2)]; // Weiß
                }
                
                // Epsilon für Float-Vergleiche
                const epsilon = 1e-10;
                
                // Weiß ist Index 5 in Ihrer 11-Farben-Palette (0-10)
                const whiteIndex = 5;
                const maxColorIndex = this.colors.length - 1;
                
                let colorIndex;
                
                if (derivative < -epsilon) {
                    // Deutlich negative Steigung: Blau-Bereich (Index 6-10)
                    const negativeRatio = Math.abs(derivative) / Math.abs(this.minDerivative);
                    const blueRange = maxColorIndex - whiteIndex; // 5 Farben
                    colorIndex = whiteIndex + Math.floor(negativeRatio * blueRange);
                    colorIndex = Math.min(maxColorIndex, colorIndex);
                    
                } else if (derivative > epsilon) {
                    // Deutlich positive Steigung: Rot-Bereich (Index 0-4)
                    const positiveRatio = derivative / this.maxDerivative;
                    const redRange = whiteIndex; // 5 Farben
                    colorIndex = whiteIndex - Math.floor(positiveRatio * redRange);
                    colorIndex = Math.max(0, colorIndex);
                    
                } else {
                    // Quasi-Null (|derivative| <= epsilon): Weiß
                    colorIndex = whiteIndex;
                }
                
                return this.colors[colorIndex];
            }
            
            mathToCanvas(x, y) {
                const [xMin, xMax] = this.functionDef.domain;
                const [yMin, yMax] = this.functionDef.range;
                
                const canvasX = this.margin + (x - xMin) / (xMax - xMin) * this.plotWidth;
                const canvasY = this.height - this.margin - (y - yMin) / (yMax - yMin) * this.plotHeight;
                
                return [canvasX, canvasY];
            }
            
            render() {
                this.ctx.fillStyle = '#f8f9fa';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                this.drawGrid();
                this.drawAxes();
                this.drawFunction();
                this.drawBall();
                
                if (this.options.showColorBar) {
                    this.drawColorBar();
                }
            }
            
            drawGrid() {
                this.ctx.strokeStyle = '#e0e0e0';
                this.ctx.lineWidth = 1;
                
                const [xMin, xMax] = this.functionDef.domain;
                const [yMin, yMax] = this.functionDef.range;
                
                for (let i = 0; i <= 10; i++) {
                    const x = xMin + (xMax - xMin) * i / 10;
                    const [canvasX] = this.mathToCanvas(x, 0);
                    this.ctx.beginPath();
                    this.ctx.moveTo(canvasX, this.margin);
                    this.ctx.lineTo(canvasX, this.height - this.margin);
                    this.ctx.stroke();
                }
                
                for (let i = 0; i <= 8; i++) {
                    const y = yMin + (yMax - yMin) * i / 8;
                    const [, canvasY] = this.mathToCanvas(0, y);
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.margin, canvasY);
                    this.ctx.lineTo(this.width - this.margin, canvasY);
                    this.ctx.stroke();
                }
            }
            
            drawAxes() {
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 2;
                
                const [xMin, xMax] = this.functionDef.domain;
                const [yMin, yMax] = this.functionDef.range;
                
                const [, xAxisY] = this.mathToCanvas(0, yMin);
                this.ctx.beginPath();
                this.ctx.moveTo(this.margin, xAxisY);
                this.ctx.lineTo(this.width - this.margin, xAxisY);
                this.ctx.stroke();
                
                const [yAxisX] = this.mathToCanvas(xMin, 0);
                this.ctx.beginPath();
                this.ctx.moveTo(yAxisX, this.margin);
                this.ctx.lineTo(yAxisX, this.height - this.margin);
                this.ctx.stroke();
                
                // Tick-Labels
                this.ctx.fillStyle = '#333';
                const fontSize = this.width <= 500 ? 10 : 12;
                this.ctx.font = `${fontSize}px Arial`;
                this.ctx.textAlign = 'center';
                
                const xTicks = 8;
                for (let i = 0; i <= xTicks; i++) {
                    const x = xMin + (xMax - xMin) * i / xTicks;
                    const [canvasX, canvasY] = this.mathToCanvas(x, yMin);
                    
                    this.ctx.strokeStyle = '#333';
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.moveTo(canvasX, canvasY - 5);
                    this.ctx.lineTo(canvasX, canvasY + 5);
                    this.ctx.stroke();
                    
                    this.ctx.fillText(x.toFixed(1), canvasX, canvasY + 20);
                }
                
                this.ctx.textAlign = 'right';
                const yTicks = 6;
                for (let i = 0; i <= yTicks; i++) {
                    const y = yMin + (yMax - yMin) * i / yTicks;
                    const [canvasX, canvasY] = this.mathToCanvas(xMin, y);
                    
                    if (Math.abs(y) > 0.01) {
                        this.ctx.strokeStyle = '#333';
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.moveTo(canvasX - 5, canvasY);
                        this.ctx.lineTo(canvasX + 5, canvasY);
                        this.ctx.stroke();
                        
                        this.ctx.fillText(y.toFixed(1), canvasX - 10, canvasY + 4);
                    }
                }
                
                // Achsenbeschriftung
                const labelFontSize = this.width <= 500 ? 12 : 14;
                this.ctx.font = `${labelFontSize}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.fillText(this.functionDef.xLabel || 'x', this.width / 2, this.height - 20);
                
                this.ctx.save();
                this.ctx.translate(25, this.height / 2);
                this.ctx.rotate(-Math.PI / 2);
                this.ctx.fillText(this.functionDef.yLabel || 'y', 0, 0);
                this.ctx.restore();
            }
            
            drawFunction() {
                this.ctx.strokeStyle = '#000000';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                
                const [xMin, xMax] = this.functionDef.domain;
                const steps = 500;
                
                for (let i = 0; i <= steps; i++) {
                    const x = xMin + (xMax - xMin) * i / steps;
                    const y = this.functionDef.func(x);
                    const [canvasX, canvasY] = this.mathToCanvas(x, y);
                    
                    if (i === 0) {
                        this.ctx.moveTo(canvasX, canvasY);
                    } else {
                        this.ctx.lineTo(canvasX, canvasY);
                    }
                }
                this.ctx.stroke();
            }
            
            drawBall() {
                const [xMin, xMax] = this.functionDef.domain;
                const currentX = xMin + (xMax - xMin) * this.ballPosition;
                const currentY = this.functionDef.func(currentX);
                const currentDerivative = this.getDerivative(currentX);
                
                const [ballX, ballY] = this.mathToCanvas(currentX, currentY);
                
                const ballColor = this.getColorFromDerivative(currentDerivative);
                
                // Schatten
                this.ctx.fillStyle = 'rgba(0,0,0,0.3)';
                this.ctx.beginPath();
                this.ctx.ellipse(ballX, ballY + 25, this.responsiveBallSize * 0.9, 4, 0, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Kugel
                this.ctx.fillStyle = ballColor;
                this.ctx.strokeStyle = '#222';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(ballX, ballY, this.responsiveBallSize, 0, 2 * Math.PI);
                this.ctx.fill();
                this.ctx.stroke();
                
                // Glanzpunkt
                this.ctx.fillStyle = 'rgba(255,255,255,0.6)';
                this.ctx.beginPath();
                this.ctx.arc(ballX - 4, ballY - 4, 4, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Werte anzeigen (vergrößert für bessere Lesbarkeit)
                this.ctx.fillStyle = '#000';
                this.ctx.strokeStyle = '#fff';
                const ballFontSize = this.width <= 500 ? 14 : 16;
                this.ctx.font = `bold ${ballFontSize}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.lineWidth = 4;
                
                // Position
                //const posText = `x = ${currentX.toFixed(2)}`;
                //this.ctx.strokeText(posText, ballX, ballY - this.responsiveBallSize - 45);
                //this.ctx.fillText(posText, ballX, ballY - this.responsiveBallSize - 45);
                
                // Ableitung
                const derivText = `Steigung = ${currentDerivative.toFixed(2)}`;
                this.ctx.strokeText(derivText, ballX, ballY - this.responsiveBallSize - 25);
                this.ctx.fillText(derivText, ballX, ballY - this.responsiveBallSize - 25);
            }
            
            drawColorBar() {
                const barX = this.width - 200;
                const barY = 30;
                const barWidth = 150;
                const barHeight = 20;
                
                this.ctx.fillStyle = 'rgba(255,255,255,0.95)';
                this.ctx.fillRect(barX - 10, barY - 30, barWidth + 20, 95);
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(barX - 10, barY - 30, barWidth + 20, 95);
                
                for (let i = 0; i < barWidth; i++) {
                    const colorIndex = Math.floor((i / barWidth) * (this.colors.length - 1));
                    this.ctx.fillStyle = this.colors[colorIndex];
                    this.ctx.fillRect(barX + i, barY, 1, barHeight);
                }
                
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(barX, barY, barWidth, barHeight);
                
                this.ctx.fillStyle = '#333';
                this.ctx.font = '12px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('1. Ableitung f\'(x)', barX + barWidth/2, barY - 10);
                
                this.ctx.font = '10px Arial';
                this.ctx.fillText(`(${this.options.colormap})`, barX + barWidth/2, barY + barHeight + 35);
                
                this.ctx.textAlign = 'left';
                this.ctx.font = '11px Arial';
                this.ctx.fillText(this.minDerivative.toFixed(2), barX, barY + barHeight + 15);
                this.ctx.textAlign = 'right';
                this.ctx.fillText(this.maxDerivative.toFixed(2), barX + barWidth, barY + barHeight + 15);
            }
            
            setupEventListeners() {
                const startBtn = this.canvas.closest('.kugelbahn-container').querySelector('.kugelbahn-start');
                
                startBtn.addEventListener('click', () => {
                    if (this.isAnimating) {
                        this.stopAnimation();
                    } else {
                        this.reset();
                        this.startAnimation();
                    }
                });
            }
            
            setupAutoStart() {
                if (!this.options.autoStart) return;
                
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting && entry.intersectionRatio >= 0.8 && !this.hasAutoStarted) {
                            setTimeout(() => {
                                this.startAnimation();
                                this.hasAutoStarted = true;
                            }, 800);
                        }
                    });
                }, { threshold: 0.8 });
                
                observer.observe(this.canvas);
            }
            
            startAnimation() {
                if (this.isAnimating) return;
                
                this.isAnimating = true;
                const startBtn = this.canvas.closest('.kugelbahn-container').querySelector('.kugelbahn-start');
                startBtn.disabled = true;
                startBtn.textContent = 'Animation läuft... (Klick zum Stoppen)';
                
                const animate = () => {
                    this.ballPosition += this.options.animationSpeed;
                    
                    if (this.ballPosition >= 1) {
                        this.ballPosition = 1;
                        this.stopAnimation();
                        return;
                    }
                    
                    this.render();
                    
                    if (this.isAnimating) {
                        requestAnimationFrame(animate);
                    }
                };
                
                animate();
            }
            
            stopAnimation() {
                this.isAnimating = false;
                const startBtn = this.canvas.closest('.kugelbahn-container').querySelector('.kugelbahn-start');
                startBtn.disabled = false;
                startBtn.textContent = 'Starte Kugel';
            }
            
            reset() {
                this.stopAnimation();
                this.ballPosition = 0;
                this.hasAutoStarted = false;
                this.isDragging = false;
                this.render();
            }
        }
        
        // Test-Funktion
        const abschnittsweiseFunktion = {
                func: (x) => {
                if (x <= 2) {
                //* Abschnitt 1: Gerade Rampe*
                return -0.5 * x + 3;
                } else if (x <= 5) {
                //* Abschnitt 2: Parabel-Senke*
                return 0.2 * (x - 3.5)*2 + 1.5;
                } else if (x <= 8) {
                // Abschnitt 3: Steiler Anstieg*
                return 2 * (x - 5) + 1.7;
                } else {
                //* Abschnitt 4: Plateau*
                return 7.7;
                }
                },
                //* Optional: Analytische Ableitung (wenn Sie sie kennen)*
                derivative: (x) => {
                if (x <= 2) {
                return -0.5; //* Konstante Steigung*
                } else if (x <= 5) {
                return 0.4 * (x - 3.5); //* Parabel-Ableitung*
                } else if (x <= 8) {
                return 2; //* Steile Steigung*
                } else {
                return 0; //* Plateau (horizontal)*
                }
                },
                domain: [0, 10],
                range: [0, 8],
                xLabel: 'Position x [cm]',
                yLabel: 'Höhe h(x) [cm]'
                };

        const myFunction = {
            func: (x) => {
                if (x <= 8) {
                    return -0.25 * x + 6;
                } else if (x <= 12) {
                    return 4.0;
                } else if (x <= 24) {
                    return -1/3* x + 8;
                } else {
                    return 0.0;
                }
            },
            derivative: (x) => {
                if (x <= 8) {
                    return -0.25;
                } else if (x <= 12) {
                    return 0.0;
                } else if (x <= 24) {
                    return -1/3;
                } else {
                    return 0.0;
                }   
            },
            domain: [0, 24],
            range: [0, 8],
            xLabel: 'Position x [cm]',
            yLabel: 'Höhe h(x) [cm]'
        };
        
        // Initialisierung
        window.addEventListener('load', () => {
            new InteractiveKugelbahn('.kugelbahn-canvas', myFunction, {
                autoStart: true,
                animationSpeed: 0.005,
                showColorBar: false,
                colormap: 'bluewhitered'
            });
        });
    </script>
</body>
</html>